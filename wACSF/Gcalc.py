import numpy as np
import pandas as pd
import random
import os
import sys
import argparse

from sklearn.cluster import KMeans
from sklearn.manifold import TSNE


def getArguments():
    #define command line arguments
    parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
    parser.add_argument("--infile", type=str, default="", help="h5 file")
    parser.add_argument("--outfileG", type=str, default="", help="output file for G functions")
    

    #if no command line arguments are present, config file is parsed
    config_file='config.txt'
    fromFile=False
    if len(sys.argv) == 1:
        fromFile=True
    if len(sys.argv) == 2 and sys.argv[1].find('--') == -1:
        config_file=sys.argv[1]
        fromFile=True

    if fromFile is True:
        print("Try to read configuration from ",config_file, "file")
        if os.path.isfile(config_file):
            args = parser.parse_args(["@"+config_file])
        else:
            args = parser.parse_args(["--help"])
    else:
        args = parser.parse_args()
        
    return args



#Read eta mu and rc generated by another script and stored inside a file
def readCoefficient(file):
    eta = []
    mu = []
    rc = []
    with open(file) as f:
        next(f)
        lines = f.readlines()
        for line in lines:
            s = line.split()
            eta.append(float(s[0]))
            mu.append(float(s[1]))
            rc.append(float(s[2]))
    return np.array(eta), np.array(mu), np.array(rc)

def cutOffFunc(Dij, rc):
    '''
    Compute the cut off function for every rc values
    Returns an array
    (see article at https://aip.scitation.org/doi/10.1063/1.5019667)
    '''
    fc=np.where(Dij < rc, 0.5 *(np.cos( (np.pi*Dij)/rc) + 1 ), 0)
    #print("fcshape=",fc.shape)
    return fc

def getZjexp(Dij, Zj,eta,mu,rc):
    f = Zj*cutOffFunc(Dij,rc)*np.exp(-eta * ((Dij - mu)**2))
    #print("fshape=",f.shape)
    return f

def getMolIdx(nAtoms):
    '''
    Computes all possible combination of indexes for atom i and j in the molecule
    '''
    # nAtoms-1 because i,i ondex are not included
    mol_idx_i = np.empty([nAtoms, nAtoms-1],dtype=int)
    for i in range(mol_idx_i.shape[0]):
        for j in range(mol_idx_i.shape[1]):
           mol_idx_i[i,j] = i
    mol_idx_j = np.empty([nAtoms, nAtoms-1],dtype=int)
    for i in range(mol_idx_j.shape[0]):
        c=0
        for j in range(mol_idx_j.shape[0]):
           if i!=j :
              mol_idx_j[i,c] = j
              c+=1

    return mol_idx_i, mol_idx_j

def getIndexedData(df):
    '''
    Returns a rearranged dictionnary containing all the data necessary to compute G in a single call
    '''
    data = { 
            'atoms_numb':        [],
            'mol_num':       [],
            'Z':             [],
            'R':             [],
            'idx_i':         [],
            'idx_j':         [],
           }

    Ntot = 0 #total number of atoms
    k=0
    for i, row in df.iterrows():
        Z = row['Atoms']
        R = np.array(row['Coordinates'])
        nAtoms = len(Z)
        #if(k<10):
        #    print(k," ", nAtoms)
        mol_idx_i, mol_idx_j = getMolIdx(nAtoms)
        data['atoms_numb'].extend([nAtoms]*nAtoms)
        data['mol_num'].extend([k]*nAtoms)
        data['Z'].extend(Z)
        data['R'].extend(R.tolist())
        data['idx_i'].extend(np.reshape(mol_idx_i[:nAtoms,:nAtoms-1]+Ntot,[-1]).tolist())
        data['idx_j'].extend(np.reshape(mol_idx_j[:nAtoms,:nAtoms-1]+Ntot,[-1]).tolist())
        Ntot += nAtoms
        k+=1
    print('k : ', k)
    data['atoms_numb'] = np.array(data['atoms_numb'])
    data['mol_num'] = np.array(data['mol_num'])
    data['Z'] = np.array(data['Z'])
    data['R'] = np.array(data['R'])
    data['idx_i'] = np.array(data['idx_i'])
    data['idx_j'] = np.array(data['idx_j'])
    return data
    
def gather(R, idx):
    '''
    Returns coordinates inside R array according to idx
    '''
    R = R.reshape(-1,3)
    #print("idxshape=",idx.shape)
    #print("R=",R.shape)
    #print("idxmax=",np.amax(idx))
    return np.take(R, idx, axis=0)

def relu(x):
    return x * (x > 0)

def calculate_interatomic_distances(R, idx_i, idx_j):
    '''
    Computes distance between atom i and atom j
    R contains all coordinates
    idx_i and idx_j are paired arrays of all combination of atom that can exist in the molecule
    '''
    #calculate interatomic distances
    Ri = gather(R, idx_i)
    #print("Ri=",Ri.shape)
    Rj = gather(R, idx_j)
    Dij = np.sqrt(relu(np.sum((Ri-Rj)**2, axis=1))) #relu prevents negative numbers in sqrt
    #print('Dijshape=',Dij.shape)
    return Dij

def segment_sum(data, idx):
    '''
    Compute sum of values inside array at idx in data
    idx is an array of index
    '''
    s = np.zeros((np.max(idx)+1,) + data.shape[1:], dtype=data.dtype)
    np.add.at(s, idx, data)
    #print('sshape=',s.shape)
    return s

def index_segment(idx,num_atoms):
    '''
    
    '''
    s = np.zeros((np.max(idx)+1,) + idx.shape[1:], dtype=idx.dtype)
    np.add.at(s, idx, idx)
    #print('idx=',idx[0:20])
    #print('s=',s.shape)
    #print('ss=',s[0:20])
    #print('numatoms=',num_atoms[0:20])
    s = s/(num_atoms-1)
    s = np.ceil(s)
    s = s.astype(np.int64)
    #print('s=',s.shape)
    #print('st=',type(s))
    return s

args = getArguments()
df = pd.read_hdf(args.infile, 'df')
index=df.index.copy()
Z = df.loc[:, 'Atoms']
print(len(index))
print("Building of indeed data....")
data =getIndexedData(df)
df = None
del df

print("Computing of interatomic distances....")
Dij = calculate_interatomic_distances(data['R'],  data['idx_i'], data['idx_j'])
Zj = np.take(data['Z'], data['idx_j'], axis=0)

print("Get index for each atom....")
idx_i_red = index_segment(data['idx_i'],data['atoms_numb'])
#print("idx_i_red=",idx_i_red)

#Read precomputed coefficient eta, mu, rc from file
eta, mu, rc = readCoefficient('Gradial.txt')

nMols = np.max(data['mol_num']) + 1

G = {}
for iMol in range(nMols):
    G[iMol] = []

#print(type(G))
#print(len(G))

#We have multiple eta, mu, rc values we want to compute G for each of them
for k in range(len(eta)):
    strtop = "G#= {:3d} / {:3d} eta= {:14.8f} mu={:14.8f} rc={:14.8f}".format(k,eta.shape[0], eta[k], mu[k], rc[k])
    print(strtop)
    #compute all G values and sum to get one G value for each atom 
    f=getZjexp(Dij, Zj,eta[k],mu[k],rc[k])
    sf = segment_sum(f, data['idx_i'])
    #Iterate and fill the output dictionnary
    for iMol in range(nMols):
        idxm =   idx_i_red[data['mol_num']==iMol]
        #if iMol<10:
        #    print("idxmtype=",type(idxm))
        #    print("idxmshape=",idxm.shape)
        G[iMol].append(sf[idxm].tolist())
        #if iMol<10:
        #    print("i, Gimol=",iMol, G[iMol])
    #print("k, e, m, rc=",k,e, mu[k], rc[k])

#Create a dataframe with G values
df = pd.DataFrame(G.values(), index=index)
#insert atoms into the dataframe
df = df.assign(Atoms=Z)

allAtoms = [1, 6, 7, 8]
for Z in allAtoms:
    data = {
        'cid':       [],
        '0':         [],
        '1':         [],
        '2':         [],
        '3':         [],
        '4':         [],
        '5':         [],
        '6':         [],
        '7':         [],
        '8':         [],
        '9':         [],
    }

    for index, row in df.iterrows():
        atoms = row['Atoms']

        for k, atom in enumerate(atoms):
            if atom == Z:
                data['cid'].append(int(index))
                for i in range(10):
                    data[str(i)].append(row[i][k])

    dataframe = pd.DataFrame(data)
    dataframe.set_index('cid', inplace=True)
    
    dataframe.to_hdf(args.outfileG, 'Z' + str(Z))
